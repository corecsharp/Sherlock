<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="AccessShouldBeReadOrWrite" xml:space="preserve">
    <value>access should be either Read or Write.</value>
  </data>
  <data name="AttributeCollectionNotInitialized" xml:space="preserve">
    <value>Attribute collection is not properly initialized, you must retrieve one with Attributes property of HtmlTagContext before using.</value>
  </data>
  <data name="AttributeIdInvalid" xml:space="preserve">
    <value>Attribute id is invalid.</value>
  </data>
  <data name="AttributeIdIsUnknown" xml:space="preserve">
    <value>Attribute id cannot be Unknown.</value>
  </data>
  <data name="AttributeNameIsEmpty" xml:space="preserve">
    <value>Attribute name cannot be empty</value>
  </data>
  <data name="AttributeNotInitialized" xml:space="preserve">
    <value>HtmlTagContextAttribute is not properly initialized, you must retrieve one through HtmlTagContext.Attributes collection.</value>
  </data>
  <data name="AttributeNotStarted" xml:space="preserve">
    <value>You should write attribute name before writing attribute value</value>
  </data>
  <data name="AttributeNotValidForThisContext" xml:space="preserve">
    <value>HtmlTagContextAttribute is not valid for the current context. Do not store context attribute across callbacks.</value>
  </data>
  <data name="AttributeNotValidInThisState" xml:space="preserve">
    <value>HtmlTagContextAttribute is not valid in this state.</value>
  </data>
  <data name="BufferSizeValueRange" xml:space="preserve">
    <value>value cannot be smaller than 1K or bigger than 80K bytes.</value>
  </data>
  <data name="CallbackTagAlreadyDeleted" xml:space="preserve">
    <value>Callback tag already has been deleted.</value>
  </data>
  <data name="CallbackTagAlreadyWritten" xml:space="preserve">
    <value>Callback tag already has been written to output.</value>
  </data>
  <data name="CannotReadFromSource" xml:space="preserve">
    <value>The source stream does not support reading.</value>
  </data>
  <data name="CannotSeekBeforeBeginning" xml:space="preserve">
    <value>Cannot seek before the beginning of the stream.</value>
  </data>
  <data name="CannotSetNegativelength" xml:space="preserve">
    <value>Length of the stream cannot be negative.</value>
  </data>
  <data name="CannotUseConverterReader" xml:space="preserve">
    <value>ConverterReader or TextWriter cannot be used as output with this converter because the converter produces byte output. Use Stream.</value>
  </data>
  <data name="CannotUseConverterWriter" xml:space="preserve">
    <value>ConverterWriter or TextReader cannot be used as input with this converter because the converter accepts byte input. Use Stream.</value>
  </data>
  <data name="CannotWriteOtherTagsInsideElement" xml:space="preserve">
    <value>Cannot write other tags inside &lt;{0}&gt; element.</value>
    <comment>.
 Parameters: 0 - elementName (string) </comment>
  </data>
  <data name="CannotWriteToDestination" xml:space="preserve">
    <value>The destination stream does not support writing.</value>
  </data>
  <data name="CannotWriteWhileCopyPending" xml:space="preserve">
    <value>Cannot write HTML while input tag or attribute copy is pending.</value>
  </data>
  <data name="ContextNotValidInThisState" xml:space="preserve">
    <value>HtmlTagContext is not valid in this state.</value>
  </data>
  <data name="ConverterReaderInInconsistentStare" xml:space="preserve">
    <value>Cannot continue using ConverterReader after exception is thrown.</value>
  </data>
  <data name="ConverterStreamInInconsistentStare" xml:space="preserve">
    <value>Cannot continue using ConverterStream after exception is thrown.</value>
  </data>
  <data name="ConverterWriterInInconsistentStare" xml:space="preserve">
    <value>Cannot continue using ConverterWriter after exception is thrown.</value>
  </data>
  <data name="CountOutOfRange" xml:space="preserve">
    <value>Count cannot be negative or greater than the length of the buffer.</value>
  </data>
  <data name="CountTooLarge" xml:space="preserve">
    <value>Count cannot be greater than the number of bytes in buffer from index till the end.</value>
  </data>
  <data name="CreateFileFailed" xml:space="preserve">
    <value>An I/O error occurred while creating the file: {0}.</value>
    <comment>.
 Parameters: 0 - filePath (string) </comment>
  </data>
  <data name="EndTagCannotHaveAttributes" xml:space="preserve">
    <value>End tag cannot have any attributes</value>
  </data>
  <data name="HtmlNestingTooDeep" xml:space="preserve">
    <value>Html tag nesting too deep, cannot convert this document.</value>
  </data>
  <data name="IndexOutOfRange" xml:space="preserve">
    <value>Index cannot be negative or greater than the length of the buffer.</value>
  </data>
  <data name="InputDocumentTooComplex" xml:space="preserve">
    <value>Input document is too complex.</value>
  </data>
  <data name="InputEncodingRequired" xml:space="preserve">
    <value>InputEncoding property is required for this conversion.</value>
  </data>
  <data name="InvalidCodePage" xml:space="preserve">
    <value>Text code page ({0}) is invalid or not installed.</value>
    <comment>.
 Parameters: 0 - codePage (int) </comment>
  </data>
  <data name="InvalidConfigurationBoolean" xml:space="preserve">
    <value>Invalid configuration, expected boolean property ({0}).</value>
    <comment>.
 Parameters: 0 - propertyId (int) </comment>
  </data>
  <data name="InvalidConfigurationInteger" xml:space="preserve">
    <value>Invalid configuration, expected integer property ({0}).</value>
    <comment>.
 Parameters: 0 - propertyId (int) </comment>
  </data>
  <data name="InvalidConfigurationStream" xml:space="preserve">
    <value>Invalid configuration, expected stream property ({0}).</value>
    <comment>.
 Parameters: 0 - propertyId (int) </comment>
  </data>
  <data name="LengthExceeded" xml:space="preserve">
    <value>The sum of offset and count ({0}) is larger than the array length ({1}).</value>
    <comment>.
 Parameters: 0 - sum (int), 1 - length (int) </comment>
  </data>
  <data name="MaxCharactersCannotBeNegative" xml:space="preserve">
    <value>maxCharacters cannot be negative.</value>
  </data>
  <data name="OffsetOutOfRange" xml:space="preserve">
    <value>Offset cannot be negative or greater than the length of the buffer.</value>
  </data>
  <data name="ParametersCannotBeChangedAfterConverterObjectIsUsed" xml:space="preserve">
    <value>Converter object parameters cannot be changed after object is being used</value>
  </data>
  <data name="PriorityListIncludesNonDetectableCodePage" xml:space="preserve">
    <value>Priority list cannot include code pages which are not detectable</value>
  </data>
  <data name="PropertyNotValidForCodepageConversionMode" xml:space="preserve">
    <value>This property cannot be used in simple codepage conversion mode</value>
  </data>
  <data name="PropertyNotValidForTextExtractionMode" xml:space="preserve">
    <value>This property cannot be used in text extraction mode</value>
  </data>
  <data name="ReadUnsupported" xml:space="preserve">
    <value>This stream does not support reading.</value>
  </data>
  <data name="SeekUnsupported" xml:space="preserve">
    <value>This stream does not support seeking.</value>
  </data>
  <data name="TagIdInvalid" xml:space="preserve">
    <value>Tag id is invalid.</value>
  </data>
  <data name="TagIdIsUnknown" xml:space="preserve">
    <value>Tag id cannot be Unknown.</value>
  </data>
  <data name="TagNameIsEmpty" xml:space="preserve">
    <value>Tag name cannot be empty.</value>
  </data>
  <data name="TagNotStarted" xml:space="preserve">
    <value>You should write a tag with WriteTag before writing tag attributes</value>
  </data>
  <data name="TagTooLong" xml:space="preserve">
    <value>Tag is too long, buffer reallocation has failed.</value>
  </data>
  <data name="TextReaderUnsupported" xml:space="preserve">
    <value>ConverterWriter or TextReader cannot be used as input with this converter. This converter accepts byte input (use Stream).</value>
  </data>
  <data name="TextWriterUnsupported" xml:space="preserve">
    <value>ConverterReader or TextWriter cannot be used as output with this converter. This converter produces byte output (use Stream).</value>
  </data>
  <data name="TooManyIterationsToFlushConverter" xml:space="preserve">
    <value>Too many iterations to flush the converter.</value>
  </data>
  <data name="TooManyIterationsToProcessInput" xml:space="preserve">
    <value>Too many iterations to process input chunk.</value>
  </data>
  <data name="TooManyIterationsToProduceOutput" xml:space="preserve">
    <value>Too many iterations to produce any output.</value>
  </data>
  <data name="WriteAfterFlush" xml:space="preserve">
    <value>Write should not be called for ConverterStream after Flush.</value>
  </data>
  <data name="WriteUnsupported" xml:space="preserve">
    <value>This stream does not support writing.</value>
  </data>
</root>